ğŸ”¥ JavaScript Execution Context (Like Akshay Saini)

âœ… Execution Context = The environment where JS code runs
ğŸŸ¢Every piece of JS code, whether global code or inside a function, runs inside an Execution Context.
ğŸŸ¢You can imagine it as a container / box that holds information about variables, functions, scope chain, this, and more.

There are two main types:

1ï¸âƒ£ Global Execution Context (GEC)
2ï¸âƒ£ Function Execution Context (FEC)

ğŸŸ¡ When is each created?
ğŸ”¹ğŸ”¹ Global Execution Context
ğŸ”¹Created when the JS engine starts running your file/script
ğŸ”¹Only one for the entire program
GEC
|
|â€”â€”- Entire JS file runs here
|

ğŸ”¹ğŸ”¹ Function Execution Context
Created when a function is called
Every function call gets its own EC
GEC
 |
 |---- FEC (for function A)
 |
 |-------- FEC (function B inside A)

ğŸ” Two PHASES of each Execution Context
ğŸ”¹Every EC goes through two phases:
ğŸ“Œ 1. Creation (Memory Allocation) Phase

In this phase, JS engine scans the code without running it yet and does these steps:

ğŸ“Œ 1. Create memory space for variables

Variables are allocated in memoryâ€¦

But var variables get value undefined
let and const are uninitialized (TDZ)
Before execution:
var a     â†’ undefined
let b     â†’ uninitialized
const c   â†’ uninitialized


ğŸ“Œ 2. Functions are stored fully {}

Functions go to memory with their code

ğŸ“Œ 3. this is set
In GEC â†’ this becomes global object (window in browser)
In FEC â†’ this depends on how function is called

ğŸŸ¡ 2. Execution Phase

Now code runs line by line:

âœ” Variables get real values
âœ” Code executes expressions
âœ” Functions are invoked
âœ” New Execution Contexts are created for called functions

ğŸŸ  Scope Chain & this
Inside each EC, one important thing is Scope Chain â€” it tells JS where to look for variables.
First check local variables
If not found, look in parent scopes
Until global is reached
This explains why nested functions can access outer variables.

