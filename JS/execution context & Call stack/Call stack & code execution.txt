ðŸ“Œ JavaScript Code Execution & Call Stack â€” Akshay Saini Style

JavaScript doesnâ€™t just run your code magically â€” thereâ€™s a system underneath that manages how, when, and where code runs.

The heart of this system is:

Execution Context

Call Stack

And every function invocation creates a new context that goes into the call stack and comes out when done.

ðŸŸ¡ Step-by-Step Execution

Hereâ€™s the example Akshay uses (explained with boxes & stack diagrams):

var n = 2;

function square(num) {
  var ans = num * num;
  return ans;
}

var square2 = square(n);
var square4 = square(4);


(This is from Akshayâ€™s video description.)

ðŸ”¹ 1. Global Execution Context (GEC)

Before any line runs:

âœ… JS engine creates the Global Execution Context
âœ… This is like a big container where all global stuff lives.

ðŸ“¦ Global EC Box

Execution Context: GLOBAL
  memory:
    n = undefined
    square = <function code>
    square2 = undefined
    square4 = undefined
  code: (the entire program)


ðŸ‘‰ JS fills undefined as placeholder in memory for all variables in the creation phase.

ðŸ”¹ 2. Code Execution Begins

Now JS starts executing line by line:

Line 1
n = 2;       // overrides undefined


ðŸ“¦ GEC now

n = 2
square = <function>
square2 = undefined
square4 = undefined

ðŸŸ¢ 3. Function Call â†’ New Execution Context

When this runs:

var square2 = square(n);


JS does:

Create a new Execution Context for square()

Push it onto the Call Stack

Run it

Pop it when finished

ðŸŸ¡ CALL STACK BEFORE function call
|----------------|
| Global EC      |
|----------------|

âž¤ Now JS calls square(n)

So it creates a new context:

ðŸ“¦ square() Execution Context

Execution Context: square
  memory:
    num = undefined
    ans = undefined
  code: body of square func


JS first allocates memory (creation phase) â†’ num & ans both undefined.

ðŸ“Œ Now CALL STACK
|----------------------|
| square EC            |
|----------------------|
| Global EC            |
|----------------------|

ðŸŸ¢ Code inside square

Now it runs the function:

Assigns num = 2

Calculates ans = num * num = 4

Returns ans

Now return means:
âœ” Pop the square EC
âœ” Go back to global context
âœ” Store return value in square2

square2 = 4


ðŸ“¦ Call Stack after pop:

|-------------------|
| Global EC         |
|-------------------|


âœ” square() execution is done â†’ its context removed.

ðŸŸ¢ Next Line
var square4 = square(4);


Same process repeats again:

âž¤ New square Execution Context
|----------------------|
| square EC (again)    |
|----------------------|
| Global EC            |
|----------------------|


JS runs:

num = 4
ans = 16
return 16


â†’ Pop square EC

Now

square4 = 16

ðŸŸ¢ Final Steps

After the code finishes:

Global EC has:
n = 2
square2 = 4
square4 = 16


Then:
ðŸ”¥ Program done
ðŸ”¥ Global execution context is popped
ðŸ”¥ Call Stack is EMPTY

ðŸŸ¡ CALL STACK VISUAL (Simplified)
| Time                | Call Stack             |
| ------------------- | ---------------------- |
| Start               | [Global EC]            |
| square(n) is called | [square EC, Global EC] |
| square returns      | [Global EC]            |
| square(4) is called | [square EC, Global EC] |
| square returns      | [Global EC]            |
| End of program      | [] (empty)             |

ðŸŸ¢ KEY POINTS (Interview Style)

âœ… JS code always runs inside an execution context
âœ… The global context is created first
âœ… Every function call creates a new context
âœ… The call stack keeps track of these contexts so execution order is managed
âœ… When a function finishes, its context is popped off the stack
âœ… JS is synchronous & single-threaded â€” so only one thing executes at a time