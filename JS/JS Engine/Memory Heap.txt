In JavaScript, the memory heap is the part of memory where objects and complex data types are stored dynamically. Itâ€™s managed automatically by the JavaScript engine (like V8 in Chrome/Node.js), so developers donâ€™t manually allocate or free it.

ðŸ§  What is the Memory Heap?

The heap is a large, unstructured region of memory

Used for:

Objects { }

Arrays [ ]

Functions

Closures

Memory size is not fixed

Managed by Garbage Collection (GC)

Think of the heap as a warehouse where JavaScript stores things whose size or lifetime is not known in advance.


| Stack                          | Heap                       |
| ------------------------------ | -------------------------- |
| Stores primitives & references | Stores objects & functions |
| Fixed size                     | Dynamic size               |
| Fast                           | Slower than stack          |
| LIFO                           | No order                   |


ðŸ“Œ Example 1: Primitive vs Object (Heap Usage)
let a = 10;
let b = a;

let obj1 = { name: "Adarsh" };
let obj2 = obj1;
Memory explanation:
STACK:
a -> 10
b -> 10
obj1 -> 0x001 (reference)
obj2 -> 0x001 (reference)

HEAP:
0x001 -> { name: "Adarsh" }

a and b store values directly in the stack

obj1 stores a reference in stack

The actual object { name: "Adarsh" } lives in the heap

obj2 points to the same heap object

ðŸ“Œ Example 2: Modifying Heap Data
let user = { age: 25 };
let admin = user;

admin.age = 30;

console.log(user.age); // 30

Why?
Both user and admin point to the same heap object.

ðŸ“Œ Example 3: Functions Stored in Heap
function greet() {
  console.log("Hello");
}

let sayHi = greet;

Function greet is stored in the heap

sayHi holds a reference to that function

ðŸ“Œ Example 4: Garbage Collection (Heap Cleanup)
let person = { name: "Reddy" };

person = null;

After this:

No references point to { name: "Reddy" }

Garbage Collector removes it from the heap

âœ” JavaScript uses Mark-and-Sweep GC

ðŸš¨ Common Heap Memory Leak Example
let users = [];

function addUser(name) {
  users.push({ name });
}

If addUser is called repeatedly:

Objects keep accumulating in heap

Memory usage grows â†’ memory leak

ðŸ§© Visual Summary
STACK                   HEAP
-----                   ----
num -> 5
obj -> 0x123  --------> { id: 1, name: "A" }
ðŸŽ¯ Key Takeaways

Heap stores objects, arrays, functions

Stack stores primitives & references

Objects are accessed via references

Unused heap memory is cleared by Garbage Collector

Memory leaks happen when references are unintentionally retained


1ï¸âƒ£ Heap vs Stack in Async JavaScript
Key idea

âž¡ï¸ Async does NOT change where memory is stored
It only changes WHEN code runs, not WHERE data lives

Example
function fetchData() {
  let user = { name: "Adarsh" };

  setTimeout(() => {
    console.log(user.name);
  }, 1000);
}

fetchData();
What happens in memory?
ðŸ§± Stack

fetchData() pushed

user reference stored in stack

setTimeout() registered

fetchData() finishes â†’ popped from stack

ðŸ§  Heap

{ name: "Adarsh" } stays in heap

Arrow function (callback) stored in heap

Callback closes over user

â± Event Loop

After 1 second â†’ callback pushed to stack

user.name accessed successfully

ðŸ”¥ Important

Even though fetchData() finished,
ðŸ‘‰ heap object is NOT destroyed because async callback still references it.

âš ï¸ Async Memory Risk
function startTimer() {
  let bigData = new Array(1e6).fill("x");

  setInterval(() => {
    console.log(bigData.length);
  }, 1000);
}

âŒ bigData never released
âŒ Closure + interval = heap memory leak

2ï¸âƒ£ How Closures Affect Heap Memory
Closure = function + remembered variables
Example
function outer() {
  let count = 0;

  return function inner() {
    count++;
    console.log(count);
  };
}

const fn = outer();
fn();
fn();
Memory Breakdown
ðŸ§± Stack

outer() runs â†’ returns inner

outer() stack frame removed

ðŸ§  Heap

count stays in heap

inner function keeps reference to count

HEAP:
count -> 0 â†’ 1 â†’ 2
inner -> reference to count
âœ… Why this is powerful

Enables data privacy

Preserves state

âŒ Why this is dangerous

Data lives longer than expected

Large objects inside closures = memory leak

âš ï¸ Closure Memory Leak Example
function attachListener() {
  let huge = new Array(1e6).fill("data");

  document.body.addEventListener("click", () => {
    console.log(huge[0]);
  });
}

âŒ huge never released
âŒ Event listener keeps closure alive

3ï¸âƒ£ How Memory Works in V8 Engine

(V8 = Chrome & Node.js JS engine)

ðŸ§  V8 Memory Areas
1ï¸âƒ£ Stack

Function calls

Primitive values

Fast, fixed size

2ï¸âƒ£ Heap (Main focus)

Divided into generations:

ðŸŸ¢ Young Generation

New objects

Short-lived

Fast GC (Scavenge)

ðŸ”µ Old Generation

Long-lived objects

Slower GC (Mark & Sweep)

Example Flow
let obj = { name: "A" };

Created â†’ Young Generation

Survives multiple GCs

Promoted â†’ Old Generation

âš ï¸ Why leaks hurt

Old generation GC is slow
â†’ App becomes laggy

ðŸ§¹ Garbage Collection (Simplified)
Mark & Sweep

Mark reachable objects

Sweep unreachable ones

Compact memory

let a = { x: 1 };
a = null; // eligible for GC
4ï¸âƒ£ How to Debug Heap Memory Leaks (Chrome DevTools)
ðŸ” Step-by-Step
ðŸ›  Step 1: Open Memory Panel
Chrome DevTools â†’ Memory
ðŸ›  Step 2: Take Heap Snapshot

Click Heap Snapshot

Perform actions (clicks, navigation)

Take another snapshot

ðŸ›  Step 3: Compare Snapshots

Look for:

Growing number of:

Objects

Closures

Detached DOM nodes

ðŸ›  Step 4: Look for Red Flags
ðŸš© Common Leak Sources

Event listeners not removed

setInterval without clearInterval

Global variables

Closures holding large objects

Detached DOM nodes

Example Fix

âŒ Leak:

setInterval(() => {
  console.log("running");
}, 1000);

âœ… Fix:

const id = setInterval(() => {
  console.log("running");
}, 1000);

clearInterval(id);
ðŸ§ª Pro Tip

Use Allocation instrumentation on timeline

Shows who allocated memory

Best for real-time leaks

ðŸ§  Final Mental Model
STACK â†’ fast, short-lived
HEAP â†’ dynamic, long-lived
ASYNC â†’ delays execution, NOT memory
CLOSURES â†’ extend heap lifetime
LEAKS â†’ references prevent GC