ğŸ—‘ï¸ Garbage Collector (GC) in JavaScript â€” with clear examples

Garbage Collector is a background process in the JavaScript engine that automatically frees memory by removing objects that are no longer reachable from your program.

ğŸ‘‰ You donâ€™t delete memory manually in JS.
ğŸ‘‰ GC decides when an object is dead and cleans it up.

ğŸ§  Core Rule (Most Important)

If an object is unreachable, it is garbage.

â€œReachableâ€ means:

Accessible from the root (global scope, current stack, closures, etc.)

Or referenced by something that is reachable

1ï¸âƒ£ Simple Example: Object Becomes Garbage
let user = { name: "Adarsh" };
user = null;
What happens?
Before:
STACK â†’ user â”€â”€â”€â”€â”€â–º HEAP â†’ { name: "Adarsh" }

After:
STACK â†’ user â†’ null
HEAP â†’ { name: "Adarsh" } âŒ unreachable

âœ… GC removes { name: "Adarsh" }
âœ… Memory is freed

2ï¸âƒ£ Reachable vs Unreachable Example
let a = { value: 10 };
let b = a;

a = null;
Memory state
STACK:
a â†’ null
b â†’ 0x101

HEAP:
0x101 â†’ { value: 10 } âœ… reachable

â— Object is NOT garbage because b still references it.

3ï¸âƒ£ Garbage Collection Algorithm (Mark & Sweep)

Modern JS engines (like V8) use Mark-and-Sweep.

ğŸ” How it works

Mark all reachable objects starting from roots

Sweep (delete) all unmarked objects

Example
let obj1 = { a: 1 };
let obj2 = { b: 2 };

obj1 = null;
During GC

{ b: 2 } â†’ marked âœ…

{ a: 1 } â†’ unmarked âŒ â†’ removed

4ï¸âƒ£ Closures & Garbage Collector

Closures can prevent GC.

function outer() {
  let data = { big: "memory" };

  return function inner() {
    console.log(data.big);
  };
}

let fn = outer();
Important

outer() finished execution

But data is still reachable via inner

âŒ GC cannot remove data

Fix (release reference)
fn = null;

Now:

inner unreachable

data unreachable

âœ… GC cleans up both

5ï¸âƒ£ GC with Async Code
function load() {
  let info = { name: "User" };

  setTimeout(() => {
    console.log(info.name);
  }, 1000);
}

load();
Key point

Even after load() ends

info stays in heap

Because async callback still references it

âœ… After callback runs and finishes â†’ GC can clean up

6ï¸âƒ£ Common Garbage Collection Pitfall (Memory Leak)
âŒ Leak Example
let cache = [];

function store() {
  cache.push({ data: new Array(1e6) });
}

cache is global

Objects are always reachable

âŒ GC will NEVER remove them

âœ… Fix
cache.length = 0;
// or
cache = null;
7ï¸âƒ£ Detached DOM Nodes (Classic GC Trap)
let div = document.createElement("div");
document.body.appendChild(div);

document.body.removeChild(div);
// div still referenced!

âŒ GC cannot remove div

Fix
div = null;
8ï¸âƒ£ What GC Can & Cannot Do
âœ… GC CAN

Remove unused objects

Clean cyclic references

Manage heap automatically

âŒ GC CANNOT

Free memory if references exist

Detect â€œlogicalâ€ memory leaks

Run at predictable times

ğŸ§  Mental Model (Interview Gold)
Reachable â†’ Alive â†’ Not collected
Unreachable â†’ Dead â†’ Collected
References keep objects alive
Closures extend object lifetime
â­ Interview One-Liner

â€œJavaScript garbage collection works on reachability.
If an object cannot be reached from the root, it becomes eligible for garbage collection using mark-and-sweep.â€