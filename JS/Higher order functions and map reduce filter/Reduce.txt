Reduce ::
Definition:
ğŸ‘‰ reduce() processes an array and reduces it to a single value (number, object, array, etc.) by applying a callback function on each element.

Perfect Syntax

array.reduce((accumulator, currentValue, index, array) => {
  return updatedAccumulator;
}, initialValue);

Simple Example (Sum):
1)
const arr = [1, 2, 3, 4];
const sum = arr.reduce((acc, curr) => acc + curr, 0);
console.log(sum); // 10


2)const arr=[2,3,4,5];
   const output = arr.reduce(function (acc,cur){
        return acc+cur;  or acc = acc+cur return acc;
    },0);

console.log(output);
How it works
accumulator â†’ stores the result(result and initial value for accumulator )
currentValue â†’ current element(each element in array loop one by one)
initialValue â†’ starting value of accumulator
Runs left to right
Returns one final value

 one-liner
ğŸ‘‰ â€œreduce() transforms an array into a single value by accumulating results using a callback function.â€

example for finding max value :: 

normally how we write ::
const arr = [1,2,3,4];
function max(arr){
    let max = 0;
    for(let i=0;i<arr.length;i++){
        if(arr[i]>max){
            max = arr[i]
        }
    }
    console.log(max);
}
max(arr);

by using reduce ::::
const arr = [1,4,3,2];

arr.reduce(function(acc,curr){
	if (curr > acc){
		acc = curr;
	}
	return acc;
},0); // 4 printed

===========================================================================================

above examples done by the freshers do this as the exp :
how many people are particular unique age :: 
{26:2,27:1,28:1}  like this 

const users = [
{name:"adarsh",firstname:"m",age:26},
{name:"john",firstname:"s",age:27},
{name:"ton",firstname:"l",age:28},
{name:"san",firstname:"h",age:26},
]

users.reduce(function (acc,curr){
  if(acc[curr.age]) {
      acc[curr.age]= acc[curr.age]+1;
  } 
    else {
        acc[curr.age] = 1
    }

   return acc; 
},{});

{26: 2, 27: 1, 28: 1}

ğŸ”¹ What this code is doing (in one line)

ğŸ‘‰ It counts how many users are there for each age.

Final output will be:

{ 26: 2, 27: 1, 28: 1 }
ğŸ”¹ What is acc?
{}

acc (accumulator) is an object

It stores the final result

Each key = age

Each value = count of users with that age

ğŸ”¹ What is curr?
{name:"adarsh", firstname:"m", age:26}

curr is the current user object during iteration

ğŸ”¹ Why acc[curr.age] ?
Step-by-step thinking:
ğŸ”¸ curr.age
curr.age === 26   // for first user
ğŸ”¸ acc[curr.age]
acc[26]

â¡ï¸ Accesses the value stored for age 26 in acc

ğŸ”¹ How it works internally (iteration-wise)
âœ… Initial value
acc = {}
ğŸ” 1st user {age: 26}
acc[26] âŒ // doesn't exist

â¡ï¸ go to else

acc[26] = 1

acc becomes:

{ 26: 1 }
ğŸ” 2nd user {age: 27}
acc[27] âŒ

â¡ï¸

acc[27] = 1

acc becomes:

{ 26: 1, 27: 1 }
ğŸ” 3rd user {age: 28}
acc[28] âŒ

â¡ï¸

acc[28] = 1

acc becomes:

{ 26: 1, 27: 1, 28: 1 }
ğŸ” 4th user {age: 26}
acc[26] âœ… exists

â¡ï¸

acc[26] = acc[26] + 1; // 1 + 1

acc becomes:

{ 26: 2, 27: 1, 28: 1 }
ğŸ”¹ Key point (VERY IMPORTANT)
acc[curr.age]

ğŸ‘‰ Means:
â€œUse the age value as a dynamic key in the object.â€

Same as:

acc["26"]

(because object keys are strings internally)

ğŸ”¹ Simplified mental model ğŸ§ 

Think of acc like this:

{
  age: count
}

So:

acc[26] = number of users aged 26
ğŸ¯ Interview one-liner

ğŸ‘‰ acc[curr.age] dynamically creates or updates an object key using the current userâ€™s age to count occurrences.


âŒ What you are thinking (but NOT happening)
26 = 26 + 1 âŒ

ğŸ‘‰ This is never happening.

âœ… What is ACTUALLY happening
acc[26] = acc[26] + 1;
Break it down ğŸ‘‡
1ï¸âƒ£ acc[26]

This does NOT mean the number 26.

It means:

acc[26]  // value stored at key "26" in the object

Earlier, we had:

acc = { 26: 1, 27: 1, 28: 1 }

So:

acc[26] === 1
2ï¸âƒ£ Right side first
acc[26] + 1

Substitute value:

1 + 1 = 2
3ï¸âƒ£ Assign back to the SAME key
acc[26] = 2

Now object becomes:

{ 26: 2, 27: 1, 28: 1 }
ğŸ”‘ SUPER IMPORTANT RULE
object[key] = value

key â†’ label / property name

value â†’ data stored

Key is NOT the value

ğŸ§  Think like this (mental model)
acc = {
  "26": 1   // key : value
}

After update:

acc = {
  "26": 2
}
ğŸ” Why acc[26] looks confusing

Because 26 is used as a key, not as a number to calculate with.

JS automatically converts it to a string:

acc["26"]
ğŸ¯ One-line interview explanation

ğŸ‘‰ acc[26] refers to the value stored at key "26" in the accumulator object, not the number 26 itself; so we increment the stored count from 1 to 2.

Iâ€™ll explain once more, end-to-end, using ONLY this strategy ğŸ‘‡

value_at_label_26 = value_at_label_26 + 1

No reduce first, no shortcuts.

ğŸ§  Step 1: Think of acc as a label â†’ value table
let acc = {};

Imagine this table (empty at start):

Label	Value
â€”	â€”
ğŸ§  Step 2: First user comes (age = 26)

Code that runs:

acc[26] = 1;

Translate to strategy:

value_at_label_26 = 1;

Table becomes:

Label	Value
26	1
ğŸ§  Step 3: Second user comes (age = 26 again)

Now this line runs:

acc[26] = acc[26] + 1;
Translate EXACTLY using the strategy:
value_at_label_26 = value_at_label_26 + 1;
ğŸ§  Step 4: Replace value_at_label_26 with actual value

From the table:

value_at_label_26 = 1

So:

value_at_label_26 = 1 + 1

Result:

value_at_label_26 = 2
ğŸ§  Step 5: Write it back to the table

Table becomes:

Label	Value
26	2

âœ” Label 26 never changes
âœ” Only the value written under it changes

ğŸ”¥ VERY IMPORTANT (this removes the confusion forever)
âŒ WRONG thinking
26 = 26 + 1 âŒ
âœ… CORRECT thinking
value_at_label_26 = value_at_label_26 + 1 âœ…
ğŸ§  Step 6: Now plug this back into reduce
users.reduce((acc, curr) => {

  // curr.age = 26

  if (acc[curr.age]) {
    // value_at_label_26 = value_at_label_26 + 1
    acc[curr.age] = acc[curr.age] + 1;
  } else {
    // value_at_label_26 = 1
    acc[curr.age] = 1;
  }

  return acc;
}, {});
ğŸ§  One-sentence understanding (memorize this)

ğŸ‘‰ acc[26] = acc[26] + 1 means: â€œincrease the value stored under label 26 by 1.â€

âœ… Final output after all users
{ 26: 2, 27: 1, 28: 1 }


âœ… Correct rule in JavaScript objects
object[key] = value;
ğŸ”¹ Left side â†’ KEY
acc[26]   // key = "26"
ğŸ”¹ Right side â†’ VALUE
acc[26] + 1   // value + 1
ğŸ” Apply this to your example
acc[26] = acc[26] + 1;

Read it as:

â€œAt key 26, store the value (current value at key 26 + 1)â€

Left side â†’ where to store

Right side â†’ what to store
===========================================================================================

Letâ€™s explain very clearly and slowly.
const users = [
{name:"adarsh",firstname:"m",age:26},
{name:"john",firstname:"s",age:27},
{name:"ton",firstname:"l",age:38},
{name:"san",firstname:"h",age:26},
]

users.reduce(function (acc,curr){
    if(curr.age < 30){
        acc = curr.name;
    }
    return acc;
},{});


Your code
users.reduce((acc, curr) => {
  if (curr.age < 30) {
    acc.push(curr.name);
  }
  return acc;
}, {});
ğŸ”´ Core problem
acc.push(curr.name);

push() exists only on arrays

{} (object) does NOT have push

So:

acc = {}
acc.push âŒ  // undefined

Thatâ€™s why it doesnâ€™t work.

âœ… Correct version
users.reduce((acc, curr) => {
  if (curr.age < 30) {
    acc.push(curr.name);
  }
  return acc;
}, []);

Now:

acc starts as an array

push() works

names get collected

ğŸ§  Golden rule (MEMORIZE THIS)
In reduce():

Use [] â†’ when you want a list (push, map, filter)

Use {} â†’ when you want keyâ€“value pairs (counts, groups)

ğŸ«™ Jar analogy (quick)

{} â†’ jars with labels

[] â†’ basket where you throw items

push() = throw item into basket