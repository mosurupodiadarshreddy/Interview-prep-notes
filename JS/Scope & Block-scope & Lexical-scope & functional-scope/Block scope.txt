ğŸŒ 1ï¸âƒ£ What is Block Scope?

A block in JavaScript is anything inside {} â€” like inside if, for, or { } by itself.

ğŸ’¡ Block Scope means that variables declared with let and const are ONLY available inside that block.

âœ” BLOCK SCOPE with let and const

Example from video:

{
  let a = 10;
  const b = 20;
  console.log(a);  // 10
  console.log(b);  // 20
}

console.log(a); // âŒ ReferenceError
console.log(b); // âŒ ReferenceError


Explanation in simple words:

âœ” a and b exist only inside the {} block
âœ– Outside the block, they donâ€™t exist, so it throws a ReferenceError

ğŸ”¥ 2ï¸âƒ£ What about var inside a block?

Example from video:

{
  var c = 30;
}
console.log(c); // 30


Simple explanation:

var does NOT have block scope

Even inside {}, var behaves like it was outside

So c is available globally

ğŸ§  Summary of Block Scope
Declaration	Block Scope?
var	âŒ No
let	âœ… Yes
const	âœ… Yes

So always use let/const and avoid var unless you need the old behavior.

ğŸŸ¢ 3ï¸âƒ£ What is Shadowing?

Shadowing means: If a variable is defined in BOTH an outer scope and an inner block, the inner one hides (or â€œshadowsâ€) the outer one inside the block.

Example from the video:

let x = 100;

{
  let x = 50;
  console.log(x); // 50
}

console.log(x);   // 100


Simple explanation:

âœ” Inside the block, x refers to the inside value 50
âœ” Outside, it still refers to the original value 100
âœ” The inner variable â€œshadowsâ€ the outer only inside the block

ğŸ”¥ 4ï¸âƒ£ Another Example (Shadowing with var, let and const)

Video example:

let a = 10;

{
  var a = 20; // âŒ SyntaxError
}


Explanation:

âš  You CANNOT use var to shadow a let or const variable in the same scope
So this throws an error

Why? Because let already created a variable in that scope, and var is not allowed to re-declare it.

ğŸŸ¡ 5ï¸âƒ£ Legal Shadowing Cases

âœ” You can shadow only when the inner scope uses let or const

Example:

var b = 10;

{
  let b = 20;
  console.log(b); // 20
}

console.log(b); // 10


âœ” Works fine because outer is var, inner is let â€” no conflict

ğŸ§¾ 6ï¸âƒ£ KEY RULES from the video (simple interview lines)

Block scope applies only to let and const

var ignores block scope completely

Shadowing is when a variable in inner scope hides the outer variable

You can shadow outer variables with let or const

You cannot shadow a let/const with a var in the same scope â€” SyntaxError

ğŸ§  WHY THIS MATTERS

ğŸ‘‰ Block scope prevents accidental overwrites
ğŸ‘‰ It helps keep variables local to where you use them
ğŸ‘‰ Shadowing lets inner blocks control their own variables without changing the outer one

ğŸ“Œ One-Liner Interview Answers

ğŸ”¹ Block scope means let and const are only available inside {} blocks.
ğŸ”¹ var does not follow block scope; itâ€™s function or global scoped.
ğŸ”¹ Shadowing is when a variable in a child scope hides the same-named variable from an outer scope.
ğŸ”¹ You can shadow with let/const, but you canâ€™t use var to shadow a let or const variable.


ğŸ§  How GEC + Block Scope Memory Works (let / const)

We already know:

When JS starts, it creates the Global Execution Context (GEC).

Now letâ€™s add the missing part ğŸ‘‡

1ï¸âƒ£ What GEC Creates (IMPORTANT)

When GEC is created, JS creates TWO main things:

GLOBAL EXECUTION CONTEXT
|
|-- Global Object (window)
|
|-- Global Lexical Environment


Inside Global Lexical Environment, memory is created for variables.

2ï¸âƒ£ Memory Allocation in Global Lexical Environment

Consider this code:

var a = 10;
let b = 20;
const c = 30;


During creation phase, memory looks like this:

Global Lexical Environment

a â†’ undefined        (var)
b â†’ <uninitialized>  (let - TDZ)
c â†’ <uninitialized>  (const - TDZ)


âœ” All variables are part of GEC
âŒ But they are stored in different places

3ï¸âƒ£ Where exactly are var, let, const stored?

This is the key part ğŸ‘‡

ğŸ”¹ var

Stored in Global Object (window)

Also accessible via lexical environment

window.a // 10

ğŸ”¹ let and const

Stored in Global Lexical Environment

NOT attached to window

window.b // undefined
window.c // undefined


So memory structure is like:

GLOBAL EXECUTION CONTEXT
|
|-- Global Object (window)
|     |-- a (var)
|
|-- Global Lexical Environment
      |-- b (let)
      |-- c (const)

4ï¸âƒ£ What happens when a BLOCK {} is encountered?

Now the new concept ğŸ‘‡

When JS enters a block (like if, for, {}):

{
  let x = 100;
  const y = 200;
}


ğŸ‘‰ JS creates a SEPARATE MEMORY BLOCK called:

Block Lexical Environment

This is created inside the current execution context.

5ï¸âƒ£ Block Lexical Environment (VERY IMPORTANT)

Memory now looks like:

GLOBAL EXECUTION CONTEXT
|
|-- Global Lexical Environment
|     |-- a (var)
|     |-- b (let)
|
|-- Block Lexical Environment
      |-- x (let)
      |-- y (const)


âœ” This block memory exists only while block is executing
âœ” After block ends â†’ memory is removed

6ï¸âƒ£ Why var is NOT stored in block memory?

Example:

{
  var z = 300;
}
console.log(z); // 300


Because:

var does NOT respect block scope

JS puts var z into Global Lexical Environment / window

NOT into Block Lexical Environment

So block memory contains only:

let
const

7ï¸âƒ£ Block Scope + Scope Chain Together

Example:

let a = 10;

{
  let b = 20;
  console.log(a);
}


How JS finds a:

1ï¸âƒ£ Look in Block Lexical Environment â†’ not found
2ï¸âƒ£ Go to Global Lexical Environment â†’ found
3ï¸âƒ£ Print 10

This walking up is the Scope Chain.

8ï¸âƒ£ Block Shadowing with Memory Blocks
let a = 10;

{
  let a = 20;
  console.log(a); // 20
}

console.log(a); // 10


Memory picture:

Global Lexical Env
|-- a = 10

Block Lexical Env
|-- a = 20   (shadows global a)


Block a hides global a inside block only.

9ï¸âƒ£ Illegal Shadowing (memory conflict)
let a = 10;

{
  var a = 20; // âŒ SyntaxError
}


Why error?

let a already exists in Global Lexical Environment

var a tries to go to global/window

JS prevents this conflict â†’ SyntaxError

ğŸ”¥ Final Mental Model (DRAW THIS IN INTERVIEW)
EXECUTION CONTEXT
|
|-- Global Object (window)
|     |-- var variables
|
|-- Lexical Environment
|     |-- let / const
|
|-- Block Lexical Environment (created per block)
      |-- let / const

ğŸ§¾ One-Line Interview Answer (VERY STRONG)

Inside an execution context, JavaScript creates separate lexical environments.
Global lexical environment stores global let and const, and every block creates its own lexical environment where block-scoped let and const are stored.