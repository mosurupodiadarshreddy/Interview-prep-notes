ğŸ§  What is this?

this is a special keyword in JavaScript that refers to â€œwho is calling the function.â€

It does NOT always refer to the function itself â€” it depends on how the function is called.

ğŸŸ¢ 1ï¸âƒ£ Global Context (Outside any function)
console.log(this);


âœ” In browser â†’ this refers to window object
âœ” So everything attached to global stays under this

Example:

var a = 10;
console.log(this.a); // 10


Because:

this â†’ window  
window.a â†’ 10

ğŸŸ¡ 2ï¸âƒ£ Inside a Normal Function
function foo() {
  console.log(this);
}
foo();


âœ” Here this also refers to global object (window)
âœ” Because function is called normally

So result is:

window object

ğŸ”µ 3ï¸âƒ£ Strict Mode ("use strict")
"use strict";
function foo() {
  console.log(this);
}
foo();


âœ” In strict mode, this becomes undefined
âœ” Not window anymore

Why?
Because strict mode avoids default global binding.

So result:

undefined

ğŸŸ  4ï¸âƒ£ Inside an Object Method
const obj = {
  name: "JS",
  say() {
    console.log(this);
  }
};
obj.say();


âœ” Here this refers to the object that called the function
âœ” So this â†’ obj

Output:

{ name: "JS", say: f }

ğŸ”¥ 5ï¸âƒ£ When One Object Calls Another Objectâ€™s Method
const obj1 = {
  name: "A",
};

const obj2 = {
  name: "B",
  fun() {
    console.log(this);
  }
};

obj2.fun();   // B
obj1.fun();   // A


âœ” this always refers to the object before the dot
âœ” So this depends on where the function is called

ğŸ§  First: ONE GOLDEN RULE (REMEMBER THIS)
ğŸ‘‰ Normal function:

this = who calls the function
function a(){
    var b =10;
    function c(){
        console.log(this.b);
    }
    c();
}
a();

so here this keyword in function c so it means it checks who called that that function if it called outside means any how a() called if it called like this means it takes GEC called means window checks b value in that here this in c function it was called by a() so it checks in a() invocation execution context it will get b there so prints .

FIRST: LET ME CORRECT ONE KEY THING IN YOUR UNDERSTANDING (VERY IMPORTANT)

You wrote this ğŸ‘‡ (this is the mistake point):

â€œthis in function c checks who called it. Since a() called c(), it will check inside a() execution context and find b.â€

âŒ This is NOT how this works
âœ… This is how scope chain works, not this.

So you are mixing scope and this.
Letâ€™s separate them clearly.

ğŸ”‘ GOLDEN SEPARATION (REMEMBER THIS)
ğŸ”¹ Scope (variables like b)

ğŸ‘‰ Decided by where code is written

ğŸ”¹ this

ğŸ‘‰ Decided by how function is called

They are two different systems.

NOW LETâ€™S FIX YOUR FIRST EXAMPLE (STEP BY STEP, YOUR WAY)
Your code:
function a() {
  var b = 10;
  function c() {
    console.log(this.b);
  }
  c();
}
a();

STEP 1ï¸âƒ£: Who calls c()?

Inside a, you are calling:

c();


This is a plain function call.

There is NO dot like:

something.c()


So rule applies:

Plain function call â†’ this = global object (window)

âœ” NOT a()
âœ” NOT a execution context
âœ” ONLY window

STEP 2ï¸âƒ£: What is this inside c()?
this === window


So this line becomes:

console.log(window.b);

STEP 3ï¸âƒ£: Does window.b exist?
var b = 10; // âŒ NO (this b is inside function a)


b is inside function a, not global.

So:

window.b === undefined

âœ… FINAL OUTPUT
undefined

ğŸš¨ VERY IMPORTANT CLARIFICATION
âŒ this does NOT look inside caller function memory
âŒ this does NOT care that a() called c()

That is scope, not this.

ğŸ” NOW COMPARE WITH SCOPE (THIS IS WHERE CONFUSION CAME)

If you wrote this instead ğŸ‘‡

function a() {
  var b = 10;
  function c() {
    console.log(b);
  }
  c();
}
a();


Output:

10


Why?

Because:

b is a variable

Variables use scope chain

c looks inside a â†’ finds b

ğŸ‘‰ NO this involved here

ğŸ§  SIMPLE LINE (MEMORISE)

this.b âŒ is NOT same as b

ğŸ§ª START FROM SOMETHING YOU ALREADY UNDERSTAND
âœ… Normal function inside object (you already get this)
const user = {
  name: "Adarsh",
  showName: function () {
    console.log(this.name);
  }
};

user.showName(); // Adarsh


âœ” showName is called using user.
âœ” So this = user
âœ” Output is correct

ğŸ”¥ NOW THE SAME THING WITH ARROW (CONFUSION STARTS)
const user = {
  name: "Adarsh",
  showName: () => {
    console.log(this.name);
  }
};

user.showName(); // âŒ undefined

â“ Why NOT "Adarsh"?

Because:

ğŸš¨ Arrow function does NOT care who calls it
ğŸš¨ It looks outside, not at user

ğŸ§  Where is this arrow function written?

It is written outside any function, at global level.

So arrow says:

"My this = global this"


In browser:

global this = window


Now check:

window.name // undefined


So:

this.name // undefined


âœ… Thatâ€™s why output is undefined

ğŸ§¾ SIMPLE LINE TO REMEMBER

Arrow function ignores the object. It takes this from outside.

ğŸ§ª REAL LIFE EXAMPLE (THIS WILL CLICK ğŸ’¡)
ğŸ¯ Example: Button click (real app case)
âŒ Wrong way (arrow function)
button.addEventListener("click", () => {
  console.log(this);
});


ğŸ‘‰ You expect this = button
ğŸ‘‰ But arrow says: â€œI donâ€™t care who clicked meâ€

So:

this = window

âœ… Correct way (normal function)
button.addEventListener("click", function () {
  console.log(this);
});


Now:

this = button


âœ” This is why event handlers should NOT use arrow functions

ğŸ” NOW YOUR CONFUSION POINT: CASE 10 (NESTED FUNCTION)
âŒ Problem Case (Normal function inside method)
const user = {
  name: "Adarsh",
  show() {
    function inner() {
      console.log(this.name);
    }
    inner();
  }
};

user.show(); // âŒ undefined

â“ Why undefined?

Step by step:

1ï¸âƒ£ show() â†’ called by user â†’ OK
2ï¸âƒ£ BUT inner() is called normally, NOT as user.inner()

So:

inner() â†’ normal function call
this â†’ window
window.name â†’ undefined


ğŸ” NOW COMPARE WITH SCOPE (THIS IS WHERE CONFUSION CAME)

If you wrote this instead ğŸ‘‡

function a() {
  var b = 10;
  function c() {
    console.log(b);
  }
  c();
}
a();


Output:

10


Why?

Because:

b is a variable

Variables use scope chain

c looks inside a â†’ finds b

ğŸ‘‰ NO this involved here

ğŸ§  SIMPLE LINE (MEMORISE)

this.b âŒ is NOT same as b

NOW YOUR MAIN CONFUSION: WHY ARROW WORKS BUT NORMAL DOES NOT

Letâ€™s fix that slowly.

âŒ NORMAL INNER FUNCTION (PROBLEM)
const user = {
  name: "Adarsh",
  show() {
    function inner() {
      console.log(this.name);
    }
    inner();
  }
};

user.show();

Step-by-step (VERY IMPORTANT):

1ï¸âƒ£ show() is called like:

user.show()


âœ” So this inside show = user

2ï¸âƒ£ But inner() is called like:

inner()


âŒ No dot
âŒ Plain function call

So:

this === window


Then:

window.name // undefined


âœ… Output: undefined

ğŸ”‘ KEY REALIZATION (THIS WILL CLICK)

inner() is NOT called as user.inner()
So this does NOT become user

âœ… ARROW FUNCTION VERSION (WHY IT WORKS)
const user = {
  name: "Adarsh",
  show() {
    const inner = () => {
      console.log(this.name);
    };
    inner();
  }
};

user.show();

Step-by-step:

1ï¸âƒ£ show() is called as:

user.show()


âœ” this inside show = user

2ï¸âƒ£ Arrow function:

() => { ... }


ğŸš« DOES NOT create its own this

So arrow says:

â€œI will use this from where I am writtenâ€

Where is it written?
ğŸ‘‰ inside show()

So:

this === user


Then:

this.name â†’ user.name â†’ "Adarsh"


âœ… Output correct

ğŸ”¥ MOST IMPORTANT LINE (WRITE THIS IN YOUR BRAIN)
âŒ Normal function:

â€œWho called me?â€

âœ… Arrow function:

â€œWhere was I written?â€