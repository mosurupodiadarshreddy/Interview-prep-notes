âš™ï¸ WHAT IS HOISTING?

Hoisting = JavaScriptâ€™s default behavior of moving declarations to the top of their scope during memory creation phase.

Important:
âœ” Only declarations are hoisted
âœ” Initializations stay where they are

Think of it like this:

CREATION PHASE (Memory Allocation)
------------------------
Declare variables â allocate space
Declare functions â store entire function

EXECUTION PHASE (Line-by-line run)
------------------------
Execute assignments + statements

ğŸ“¦ EXECUTION CONTEXT â€” 2 PHASES

Before any code runs:

1ï¸âƒ£ Creation Phase
2ï¸âƒ£ Execution Phase

ğŸ“Œ 1ï¸âƒ£ Creation Phase

During this, JS engine:

âœ” Allocates memory for all variables
âœ” Allocates memory for all function declarations
âœ” Sets up this
âœ” Sets up scope chain

Memory Allocation:

var a  â†’ undefined
let b  â†’ uninitialized (TDZ)
const c â†’ uninitialized (TDZ)
function foo() â†’ entire function stored


Important:

var gets undefined

let and const are hoisted but are uninitialized

Accessing them before declaration âœ ReferenceError

ğŸ“œ 2ï¸âƒ£ Execution Phase

Now JS executes code top to bottom, replacing undefined with actual values.

ğŸ§  SCOPE â€” Where variables live
ğŸŒ Global Scope

Defined outside all functions/blocks.

In browsers, global var becomes a property of window.

var a = 10;
console.log(window.a); // 10


But:

let b = 20;
console.log(window.b); // undefined


So:
| Variable | Attached to window? |
| -------- | ------------------- |
| var      | Yes                 |
| let      | No                  |
| const    | No                  |
| function | Yes (global)        |

ğŸ“¦ Function Scope

Each function has its own scope.

function fn() {
  var x = 1;
}
console.log(x);  // ReferenceError

ğŸ§± Block Scope

Blocks {} create scope for let and const, NOT var.

{
  var a = 1;    // global / function
  let b = 2;    // block
}
console.log(a); // 1
console.log(b); // ReferenceError

ğŸ§  VARIABLE HANDLING & HOISTING
ğŸŸ¡ var
console.log(a); // undefined
var a = 5;


Behind the scenes:

var a;                // creation phase
console.log(a);       // undefined
a = 5;                // execution


So:
âœ” var variables become undefined if accessed before declaration
âœ” No error

ğŸ”µ let / const
console.log(b); // ReferenceError
let b = 10;

console.log(c); // ReferenceError
const c = 20;


Even though theyâ€™re hoisted, theyâ€™re in Temporal Dead Zone (TDZ) until assigned.

TDZ starts here
console.log(b); // âŒ ReferenceError
let b = 10;     // initialization
TDZ ends here


must be declared before use

ğŸ§  WHY var becomes undefined?

Only var is initialized to a default value (undefined) in the creation phase.

But for let/const, memory space exists but they are uninitialized and cannot be accessed until after declaration.

ğŸ§  FUNCTIONS AND HOISTING
â–¶ï¸ Function Declaration
hello(); // works

function hello() {
  console.log("Hello!");
}


Both declaration and definition are hoisted:

function hello() {...}  // stored
hello();                // runs

â–¶ï¸ Function Expression
sayHi(); // TypeError

var sayHi = function () {
  console.log("Hi");
};


Why TypeError?

Behind the scenes:

var sayHi = undefined;
// sayHi() â†’ undefined() â†’ TypeError


Important:
âœ” Function expressions behave like variables

â–¶ï¸ Arrow Function

Arrow functions are also function expressions:

sayHello(); // TypeError

var sayHello = () => {
  console.log("Hello");
};


Same as function expression.

ğŸ§  ERROR TYPES EXPLAINED

Letâ€™s see what different errors mean:

â— undefined

This is a value, NOT an error.

var a;
console.log(a); // undefined


Means: variable exists, but no value assigned yet.

âŒ ReferenceError

Occurs when the variable is not defined in scope or inside TDZ.

console.log(b); // ReferenceError
let b = 10;

âŒ SyntaxError

This is a compile-time error.

Example:

let 5hello; // SyntaxError


Meaning: Invalid syntax â€” cannot run.

âŒ TypeError

Occurs when type doesnâ€™t support an operation.

var a = undefined;
a(); // TypeError: a is not a function

ğŸ§  WHY window.a works for var but NOT let/const

Global:

var a = 10;
console.log(window.a); // 10


But:

let b = 20;
console.log(window.b); // undefined


â¤ Because:

var attaches to global object (window)

let / const do NOT

This explains many interview questions.

ğŸ“Š VISUAL MEMORY MODEL
âœ³ï¸ WHEN CODE RUNS
1ï¸âƒ£ Creation Phase
--------------------
var a       â†’ undefined
let b       â†’ TDZ
const c     â†’ TDZ
function fn â†’ stored fully

2ï¸âƒ£ Execution Phase
--------------------
a = 10
b = 20
c = 30

ğŸ“Œ SCOPES
GLOBAL CONTEXT
  â””â”€â”€ var a
  â””â”€â”€ let b
  â””â”€â”€ const c
  â””â”€â”€ fn()

FUNCTION CONTEXT
  â””â”€â”€ var x
  â””â”€â”€ let y
  â””â”€â”€ const z

BLOCK CONTEXT (inside {})
  â””â”€â”€ let x
  â””â”€â”€ const y
  â””â”€â”€ (var is NOT block scoped)

ğŸŸ  Summary Interview Answers
âœ” What is hoisting?

JS moves declarations to the top of their scope before execution.

âœ” var vs let vs const
var â†’ hoisted + initialized (undefined)
let/const â†’ hoisted + uninitialized (TDZ)

âœ” Why window.a works only for var?

var in global scope becomes a window property.

âœ” Function vs Arrow Function hoisting?
function declaration â†’ fully hoisted
function expression / arrow â†’ only variable hoisted â†’ TypeError if called before init

âœ” Error types
undefined â†’ no value
ReferenceError â†’ not in scope
SyntaxError â†’ bad code
TypeError â†’ wrong type operation


ğŸ”‘ Short Answer (Interview-Ready)

var gets memory in the Global Execution Context and becomes a property of window.
let and const also get memory in the Global Execution Context, but they do NOT become properties of window.

Now letâ€™s expand this properly so there is zero confusion.

ğŸ§  1ï¸âƒ£ Global Execution Context (GEC) â€“ What gets created?

When JS starts running your file:

Global Execution Context is created


Inside GEC, two important things happen:

1ï¸âƒ£ Memory is allocated for variables & functions
2ï¸âƒ£ Global object (window in browser) is created

ğŸ§± 2ï¸âƒ£ Memory Allocation in GEC (Creation Phase)

Consider this code:

var a = 10;
let b = 20;
const c = 30;

ğŸ” During Creation Phase, memory looks like this:
GLOBAL EXECUTION CONTEXT (Memory)

a  â†’ undefined        (var)
b  â†’ <uninitialized>  (let, TDZ)
c  â†’ <uninitialized>  (const, TDZ)


âœ” All three get memory in GEC
âŒ But they are handled differently

ğŸŒ 3ï¸âƒ£ var and the window object (KEY DIFFERENCE)

In browser environment:

var a = 10;


â¡ï¸ This does TWO things:

1ï¸âƒ£ Allocates memory in GEC
2ï¸âƒ£ Attaches a to window

window.a === 10  // âœ… true


So conceptually:

window = {
  a: 10
}

ğŸš« 4ï¸âƒ£ let and const DO NOT attach to window
let b = 20;
const c = 30;

window.b // undefined
window.c // undefined


Why?

Because:

let and const are stored in Lexical Environment

They are not properties of the global object

Even though they are in GEC, they live in a separate memory space

ğŸ§  5ï¸âƒ£ Important Mental Model (Akshay-Style)

Think of GEC like this:

GLOBAL EXECUTION CONTEXT
|
|-- Global Object (window)
|     |-- var variables
|     |-- function declarations
|
|-- Lexical Environment
      |-- let variables
      |-- const variables


âœ” Same execution context
âŒ Different memory areas

âš ï¸ 6ï¸âƒ£ Why let/const are NOT on window?

This was a design decision to avoid:

Accidental global pollution

Name collisions

Bugs caused by var

Thatâ€™s why:

let a = 10;


is safer than:

var a = 10;

ğŸ§ª 7ï¸âƒ£ Live Example (Browser Console)
var x = 1;
let y = 2;
const z = 3;

console.log(window.x); // 1
console.log(window.y); // undefined
console.log(window.z); // undefined

ğŸ§  8ï¸âƒ£ Common Interview Trap

â“ Does let / const get hoisted?

âœ” YES
But:

They are in Temporal Dead Zone

Cannot be accessed before declaration

console.log(b); // ReferenceError
let b = 10;

ğŸ§¾ 9ï¸âƒ£ One-Line Interview Answers (MEMORIZE)

var â†’ allocated in GEC + attached to window

let/const â†’ allocated in GEC but NOT attached to window

let/const live in lexical environment

TDZ prevents accessing variables before initialization

ğŸ”¥ Final Clear Sentence (BEST)

In the global scope, var variables become properties of the global object, while let and const are stored in the lexical environment and are not accessible via window.