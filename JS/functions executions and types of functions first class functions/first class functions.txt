1)what is anonymous function?
1A) a function with out name is called anonymous function 

******function statement
******function expression
******function declaration
******anonymous functions
******named function expression
******diff btw parameters and arguments ?
******first class functions 
******arrow functions
*******************************************************************************************
******function statement:::
example : function a(){
	console.log("a called");
}
A function statement (also called function declaration) is a function defined using the function keyword with a name.
â€œFunction statements are hoisted entirely, making them ideal for reusable, top-level logic where early invocation and clear structure are needed.â€

function a() {
  console.log("a called");
}
ðŸ§  Key Characteristics (Very Important)
1ï¸âƒ£ Fully Hoisted
Function statements are hoisted with their entire body.
a();   // âœ… works
function a() {
  console.log("a called");
}

ðŸ’¡ Why?

During memory creation phase, JS stores the whole function
So itâ€™s callable before declaration

2ï¸âƒ£ Has Its Own Scope

Variables inside the function are local to the function.
function a() {
  var x = 10;
}
console.log(x); // âŒ ReferenceError
3ï¸âƒ£ Must Have a Name

This is mandatory:

function () { }   // âŒ SyntaxError
ðŸ”¹ When Should You Use Function Statements? (MOST IMPORTANT)
âœ… Use Case 1: Utility / Helper Functions (MOST COMMON)

When you have reusable logic used across the file.

function calculateTotal(price, tax) {
  return price + tax;
}

âœ” Clean
âœ” Readable
âœ” Reusable

ðŸ“Œ This is the #1 real-world use case

âœ… Use Case 2: When Hoisting Is Helpful

When functions are used before their definitions.

init();
function init() {
  loadConfig();
  startApp();
}

ðŸ“Œ Common in:

App bootstrap code
Initialization logic

*******************************************************************************************
function expression :: 
var b = function (){
	console.log("b called");
}
A function expression is when a function is assigned to a variable.
The function can be anonymous or named, and it is NOT hoisted like a function statement.
â€œA function expression behaves like a variable; only the variable is hoisted, not the function definition.â€

var b = function () {
  console.log("b called");
};

ðŸ“Œ Here:
b is the variable
Te function is treated as a value
Assigned at runtime

ðŸ”¥ PERFECT EXAMPLE (Statement vs Expression)
âœ… Function Statement
a();   // âœ… works

function a() {
  console.log("a called");
}
Output
a called
âŒ Function Expression
b();   // âŒ TypeError

var b = function () {
  console.log("b called");
};
Output
TypeError: b is not a function
â“ Why this error?

During hoisting phase:

b â†’ undefined

So calling:

b();

is actually:

undefined();

âŒ

ðŸ”¹ Correct Way to Call Function Expression
var b = function () {
  console.log("b called");
};

b();   // âœ…
Output
b called
ðŸ§  MAIN GOLD DIFFERENCE (1-LINE ANSWER)

â€œFunction statements are hoisted with their body, whereas function expressions are hoisted only as variables.â€

| Feature                     | Function Statement | Function Expression    |
| --------------------------- | ------------------ | ---------------------- |
| Definition style            | `function a(){}`   | `var a = function(){}` |
| Hoisting                    | âœ… Full hoisting    | âŒ Only variable        |
| Callable before declaration | âœ… Yes              | âŒ No                   |
| Treated as value            | âŒ No               | âœ… Yes                  |
| Common usage                | Core logic         | Callbacks, closures    |
| Debugging                   | Easier             | Slightly harder        |

â€œA function expression behaves like a variable; only the variable is hoisted, not the function definition.â€

*******************************************************************************************
function declaration is nothing but function statement 
*******************************************************************************************
function anonymous::

ðŸ”¹ Anonymous Function â€” Definition

An anonymous function is a function without a name.
It does not have its own identity, so it cannot stand alone as a function statement.

function () {
  // âŒ SyntaxError
}
âŒ Why is this a syntax error?

Because:

Function statements MUST have a name

JavaScript parser expects an identifier after function.

ðŸ”¹ Correct Way to Use Anonymous Functions

Anonymous functions are valid only when used as values, such as:

1ï¸âƒ£ Assigned to a variable (Function Expression)
var x = function () {
  console.log("x called");
};
Output
x called
2ï¸âƒ£ Passed as an argument (Callback)
setTimeout(function () {
  console.log("Executed later");
}, 1000);


ðŸ”¥MAIN USE CASES (WITH PERFECT EXAMPLES)
âœ… Use Case 1: Callbacks (MOST COMMON)
function fetchData(callback) {
  callback();
}

fetchData(function () {
  console.log("Data fetched");
});
Output
Data fetched

ðŸ“Œ Why anonymous?

Used only once

No reuse required

âœ… Use Case 2: Event Handlers
button.addEventListener("click", function () {
  console.log("Button clicked");
});

ðŸ“Œ No need to name a function used only for one event.

âœ… Use Case 3: Closures
function outer() {
  var count = 0;

  return function () {
    count++;
    console.log(count);
  };
}

var counter = outer();
counter();
counter();
Output
1
2

ðŸ“Œ Anonymous function retains access to count.

*******************************************************************************************

example important for interview ::


************ 
function a() {
  console.log("a called");
}

var b = function xyz() {
  console.log("b called");
}

a();
b();
xyz();   // âŒ ReferenceError

ðŸ”« Interview Gun-Point Explanation
a is a function statement
Fully hoisted
Available in global scope
Can be called as a()
b is a variable holding a function expression
b is the callable reference
Function is executed using b()
xyz is a named function expression
Name xyz is NOT added to outer (global) scope
It exists only inside the function body
Calling xyz() outside â†’ âŒ ReferenceError: xyz is not defined
â€œFunction statements create globally scoped names, while named function expressions expose only the variable, not the function name itself.â€
*******************************************************************************************
named function expression ::: 
ðŸ”¹ Named Function Expression â€” Definition

A Named Function Expression is a function expression where the function has a name, but that name is scoped only to the function itself.

var b = function xyz() {
  console.log("b called");
};
ðŸ”« Gun-Point Facts (Memorize)
It is a function expression, not a function statement
The variable name (b) is used to call the function
The function name (xyz) is NOT available outside
xyz exists only inside its own function scope
Helps in debugging and recursion

âŒ What You Cannot Do
xyz();   // âŒ ReferenceError

Reason:
xyz is not added to global scope

âœ… What You Can Do
b();     // âœ…
ðŸ”¥ Perfect Interview Example
var factorial = function fact(n) {
  if (n === 1) return 1;
  return n * fact(n - 1);
};

console.log(factorial(5));
Output
120

ðŸ“Œ fact is accessible only inside the function for recursion.

ðŸ§  GOLD INTERVIEW LINE (Must Say)
â€œA named function expression creates a private function name that is accessible only within the function body.â€

*******************************************************************************************

diff between function parameters and arguments :: 

ðŸ”¹ Function Parameters â€” Definition
Parameters are the placeholders (variables) listed in the function definition that receive values.

function add(a, b) {   // a, b â†’ parameters
  console.log(a + b);
}

ðŸ”¹ Function Arguments â€” Definition
Arguments are the actual values passed to the function when it is invoked.

add(10, 20);   // 10, 20 â†’ arguments
ðŸ”¥ PERFECT INTERVIEW EXAMPLE
function multiply(x, y) {   // parameters
  console.log(x * y);
}

multiply(5, 4);             // arguments
Output
20
ðŸ”« Gun-Point Differences (Memorize)
| Aspect                  | Parameters                  | Arguments          |
| ----------------------- | --------------------------- | ------------------ |
| Where defined           | Function definition         | Function call      |
| What they are           | Variables / placeholders    | Actual values      |
| When created            | During function declaration | During invocation  |
| Scope                   | Inside function             | Passed from caller |
| Can be different names? | Yes                         | Yes                |
ðŸ§  GOLD INTERVIEW LINE

â€œParameters are variables declared in a function definition, while arguments are the actual values supplied to those variables when the function is called.â€

âš ï¸ Common Interview Follow-ups (Bonus)
Fewer arguments than parameters
function test(a, b) {
  console.log(a, b);
}
test(10);
Output:10 undefined

More arguments than parameters
function test(a) {
  console.log(a);
}
test(10, 20, 30);

Output:10

(Extra arguments are ignored unless accessed via arguments object / rest ...args)

ðŸ One-Line Summary (Ultra Gold)

â€œParameters are defined at function creation; arguments are supplied at function execution.â€
*******************************************************************************************

first class functions ::: 
ðŸ”¹ What is a First-Class Function? (Definition)
-----The ability of to use function as values and passing as argument and returned from functions is known as first class functions -----
In JavaScript, functions are first-class citizens, which means functions are treated like any other value.

ðŸ‘‰ They can be:

Assigned to variables
Passed as arguments
Returned from other functions
Stored in data structures

ðŸ§  GOLD INTERVIEW LINE (Must Remember)

â€œA language supports first-class functions if functions can be treated like values.â€

ðŸ”¥ Proof with Examples (VERY IMPORTANT)
1ï¸âƒ£ Assign a Function to a Variable
var greet = function () {
  console.log("Hello");
};

greet();
Output
Hello

ðŸ“Œ Function behaves like a value stored in greet.

2ï¸âƒ£ Pass a Function as an Argument (Callback)
function execute(fn) {
  fn();
}

execute(function () {
  console.log("Function passed as argument");
});
Output
Function passed as argument

ðŸ“Œ This is why callbacks work in JS.

3ï¸âƒ£ Return a Function from Another Function
function outer() {
  return function () {
    console.log("Returned function");
  };
}

var inner = outer();
inner();
Output
Returned function

ðŸ“Œ This enables closures.

4ï¸âƒ£ Store Functions in Data Structures
var arr = [
  function () { console.log("One"); },
  function () { console.log("Two"); }
];

arr[0]();
arr[1]();
Output
One
Two
ðŸ”¹ Why JavaScript Needs First-Class Functions

Because of first-class functions, JS supports:

Callbacks

Closures

Higher-order functions (map, filter, reduce)

Event handling

Async programming

React hooks & components

ðŸ”¹ First-Class Function vs Higher-Order Function (Quick Clarification)
| Term                      | Meaning                                  |
| ------------------------- | ---------------------------------------- |
| **First-Class Function**  | A language feature (functions as values) |
| **Higher-Order Function** | A function that uses other functions     |


Example of higher-order function:

function higherOrder(fn) {
  return fn;
}

ðŸ‘‰ Higher-order functions are possible ONLY because functions are first-class.

ðŸ§  One-Line Interview Killer Answer

â€œJavaScript treats functions as first-class citizens, meaning they can be assigned, passed, returned, and stored just like any other value.â€
*******************************************************************************************
arrow functions :: 
ðŸ”¹ What is an Arrow Function?

An arrow function is a shorter syntax for writing functions in JavaScript, introduced in ES6, with different this behavior.

const add = (a, b) => {
  return a + b;
};
ðŸ§  GOLD INTERVIEW LINE (Must Say)

â€œArrow functions do not have their own this; they inherit this from the surrounding lexical scope.â€

ðŸ”¹ Syntax Variations (Quick)
// Normal
const add = (a, b) => {
  return a + b;
};

// Implicit return
const add = (a, b) => a + b;

// Single parameter
const square = x => x * x;

// No parameters
const greet = () => console.log("Hello");
ðŸ”¥ Arrow Function vs Normal Function (KEY DIFFERENCES)

| Feature       | Normal Function       | Arrow Function          |
| ------------- | --------------------- | ----------------------- |
| Syntax        | Verbose               | Short                   |
| `this`        | Dynamic (call-site)   | Lexical (from parent)   |
| `arguments`   | Available             | âŒ Not available         |
| `new` keyword | âœ… Can be used         | âŒ Cannot                |
| Hoisting      | Yes (declaration)     | âŒ No                    |
| Best use      | Methods, constructors | Callbacks, inline logic |

ðŸ”¹ MOST IMPORTANT PART â†’ this Difference
âŒ Normal Function (loses this)
const obj = {
  x: 10,
  show: function () {
    setTimeout(function () {
      console.log(this.x);
    }, 1000);
  }
};

obj.show();
Output
undefined
âœ… Arrow Function (inherits this)
const obj = {
  x: 10,
  show: function () {
    setTimeout(() => {
      console.log(this.x);
    }, 1000);
  }
};

obj.show();
Output
10

ðŸ“Œ Arrow function takes this from show().

ðŸ”¹ When to Use Arrow Functions (IMPORTANT)
âœ… Use Arrow Functions When:

1ï¸âƒ£ Callbacks

arr.map(x => x * 2);

2ï¸âƒ£ Inline logic

button.addEventListener("click", () => {
  console.log("clicked");
});

3ï¸âƒ£ Preserving this

setTimeout(() => this.loadData(), 1000);

4ï¸âƒ£ Functional programming

const sum = (...nums) => nums.reduce((a, b) => a + b);

